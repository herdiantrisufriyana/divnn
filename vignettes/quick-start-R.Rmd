---
title: "Quick Start"
author:
  - name: Herdiantri Sufriyana
    affiliation:
    - &gibi Graduate Institute of Biomedical Informatics, College of Medical
      Science and Technology, Taipei Medical University, Taipei, Taiwan
    - Department of Medical Physiology, College of Medicine, University of
      Nahdlatul Ulama Surabaya, Surabaya, Indonesia
    email: herdiantrisufriyana@unusa.ac.id
  - name: Yu-Wei Wu
    affiliation:
    - *gibi
    - &tmuh Clinical Big Data Research Center, Taipei Medical University
      Hospital, Taipei, Taiwan
  - name: Emily Chia-Yu Su
    affiliation:
    - *gibi
    - *tmuh
    - Research Center for Artificial Intelligence in Medicine, Taipei Medical
      University, Taipei, Taiwan
package: divnn
abstract: >
  This vignette explains how to use this package using simulated data. However,
  reader may need to read another vignette to apply the DeepInsight Visible
  Neural Network (DI-VNN) model.
output:
  BiocStyle::html_document:
    toc_float: true
vignette: >
  %\VignetteIndexEntry{Quick Start}
  %\VignetteEngine{knitr::knitr}
  %\VignetteEncoding{UTF-8}
---

```{r Load this package, include=FALSE}
devtools::load_all(".")
library(divnn)
```

```{r Load other packages, include=FALSE}
library(dplyr)
library(tidyr)
library(stringr)
library(readr)
library(tibble)
library(ggplot2)
library(BiocGenerics)
library(Biobase)
library(pbapply)
library(matrixStats)
Sys.setenv('CUDA_VISIBLE_DEVICES'=-1)
library(keras)
use_backend('tensorflow')
```

# Load simulated data

Load simulated data using this code.

```{r Create input example, echo=TRUE}
input=input_example()
```

The first input is an instance-feature value data frame with rows for instances
and columns for features. All rows in value should have names. All
values should be numerics.

```{r echo=FALSE}
input$value %>%
  cbind(data.frame(outcome=input$outcome)) %>%
  group_by(outcome) %>%
  summarize_all(function(x)paste(round(mean(x),2),'Â±',round(sd(x),2))) %>%
  gather(attribute,value,-outcome) %>%
  rbind(
    table(input$outcome) %>%
      as.data.frame() %>%
      rename(outcome=Var1,value=Freq) %>%
      mutate(outcome=as.double(outcome)-1) %>%
      mutate(attribute='outcome') %>%
      select(outcome,attribute,value)
  ) %>%
  mutate(outcome=paste0('outcome_',outcome)) %>%
  spread(outcome,value) %>%
  knitr::kable(
    format='html'
    ,caption='Summary of instance-feature value data frame'
  ) %>%
  kableExtra::kable_styling(full_width=T)
```

The second input is and outcome vector of binary integers with the same length
as the instances. The length and the order of outcome should be the same with
those of value. Value  of 0 and 1 should refer to non-event and event outcome,
respectively.

```{r Outcome vector, echo=FALSE}
input$outcome[1:10]
```

The third input is a similarity matrix of numerics containing feature-feature
similarity measures.

```{r echo=FALSE}
input$similarity %>%
  knitr::kable(format='html',caption='Feature similarity matrix') %>%
  kableExtra::kable_styling(full_width=T)
```

The fourth input is a feature three-dimensional mapping matrix of numerics with
rows for features and three columns for three dimensions where the features
are mapped onto.

```{r echo=FALSE}
input$mapping %>%
  as.data.frame() %>%
  rename_all(function(x)str_replace_all(x,'V','dimension ')) %>%
  knitr::kable(format='html',caption='Feature three-dimensional mapping matrix') %>%
  kableExtra::kable_styling(full_width=T)
```

The fifth input is an ontology data frame with rows for ontologies and four
columns for source, target, similarity, and relation. Feature (source)-
ontology (target) relation should be annotated as 'feature', while ontology-
ontology relation should be annotated as 'is_a'. To differentiate between
feature and ontology names, a prefix of 'ONT:' precedes an ontology name. All
columns except similarity in ontology should be characters. Similarity
(a numeric) is a minimum threshold by which either features or ontologies
(source) belong to an ontology (target).

```{r echo=FALSE}
input$ontology %>%
  knitr::kable(format='html',caption='Ontology data frame') %>%
  kableExtra::kable_styling(full_width=T)
```

In addition, a result of hierarchical clustering is also shown below for
visualization to get intuition how the features are grouped and how the
connection constructs the VNN model architecture.

```{r figure-1, echo=FALSE, fig.cap='Ontology by hierarchical clustering'}
plot(input$hierarchy)
```

# Create TidySet

Create a TidySet using this code.

```{r Create a TidySet, eval=FALSE, echo=TRUE}
tidy_set=
  create_tidy_set(
    value=input$value
    ,outcome=input$outcome
    ,similarity=input$similarity
    ,mapping=input$mapping
    ,ontology=input$ontology
  )
```
```{r include=FALSE}
tidy_set=read_ts_tar_gz('quick-start/tidy_set_R.ts.tar.gz')
```

TidySet is an ExpressionSet with three tables. Instance-feature
value data frame and outcome vector are compiled as a phenotype data frame
with rows for instances and columns for features and outcome.

```{r TidySet, echo=FALSE}
tidy_set
```

Instance-feature value data frame and feature three-dimensional mapping matrix
are compiled as an expression matrix with rows for positions of features and
columns for instances. The mapping and similarity matrices and ontology data
frame are compile as a feature data frame with rows for positions of features
and columns for feature names and ontological relations. For easier access,
the original ontology data frame is included in experiment information at
section 'notes' as a list.

```{r echo=FALSE}
list(
    `Phenotype data frame`=pData(tidy_set) %>% dim
    ,`Feature data frame`=fData(tidy_set) %>% dim
    ,`Expression matrix`=exprs(tidy_set) %>% dim
  ) %>%
  do.call(rbind,.) %>%
  as.data.frame() %>%
  rename_all(function(x)str_replace_all(x,'V','dimension ')) %>%
  knitr::kable(format='html',caption='Dimensions of three tables') %>%
  kableExtra::kable_styling(full_width=T)
```

Recall experiment notes such similarity, ontomap, ontotype, and ontology using
this code.

```{r Recall experiment notes, eval=FALSE, echo=TRUE}
# Recall a similarity matrix
notes(tidy_set)$similarity

# Recall an ontomap four-dimensional array
notes(tidy_set)$ontomap

# Recall an ontotype list of two-dimensional matrices
notes(tidy_set)$ontotype

# Recall an ontology data frame
notes(tidy_set)$ontology
```

# Save or load a TidySet

Use this code to save a TidySet by writing a .ts.tar.gz file containing
exprs.csv, pData.csv, fData.csv, similarity.csv, ontology.csv, and others.txt.

```{r Save a TidySet, eval=FALSE, echo=TRUE}
write_ts_tar_gz(tidy_set,'quick-start/tidy_set_R')
```

Function of read_ts_tar_gz can read this file back to a TidySet. Use
this code to load a TidySet by reading a .ts.tar.gz file.

```{r Load a TidySet, eval=FALSE, echo=TRUE}
tidy_set=read_ts_tar_gz('quick-start/tidy_set_R.ts.tar.gz')
```


# Create ontonet

Let's create a function that generate a Keras Convolutional Neural Network (CNN)
model with a specific layer architecture for each path in the hierarchy of the
given ontology. The model architecture can be saved to JSON for later use by
specifying the file path; otherwise (by let it NULL), no JSON will be created.

```{r Create ontonet generator function, eval=FALSE, echo=TRUE}
ontonet=
  tidy_set %>%
  ontonet_generator(path='quick-start/ontonet_R')
```
```{r include=FALSE}
ontonet=
  readLines('quick-start/ontonet_R.json') %>%
  model_from_json()
```


# Set up hyperparameters

The model is compiled with stochastic gradient decent (SGD)
using learning rate (LR) of 2^-6, momentum of 0.9, and decay 10^-4. The loss
function is mean squared error (MSE) with weight of 1 for main output and 0.3
fir auxiliary output. The evaluation metric is accuracy.

The LR will be reduce by factor of 0.1 at iteration 30, 60, and 80. Early
stopping will also happen if validation loss does not decrease >0.001 after
30 iteration. The best weight at minimum validation loss will be applied.

```{r Set up hyperparameters with callbacks, echo=TRUE}
ontonet %>%
  compile(
    optimizer=optimizer_sgd(lr=2^-6,momentum=0.9,decay=10^-4)
    ,loss='mean_squared_error'
    ,loss_weights=c(rep(0.3,length(.$outputs)-1),1)
    ,metrics='accuracy'
  )

cb_lr_reduction=
  callback_learning_rate_scheduler(
    function(epoch,lr){
      lr_factor=0.1
      if(epoch %in% c(30,60,80)) lr=lr*lr_factor
      lr
    }
  )

cb_early_stopping=
  callback_early_stopping(
    monitor='val_loss'
    ,mode='min'
    ,min_delta=0.001
    ,patience=30
    ,restore_best_weights=T
  )
```

# Data partition

We hold out ~20% dataset for test set, while ~20% of the remaining will be a
validation set. Training set

```{r Randomize sample for test set then validation and train sets, echo=FALSE}
set.seed(33)
index=sample(1:dim(tidy_set)[2],dim(tidy_set)[2],F)

test_i=
  index %>%
  sample(round(0.2*length(.)),F)

val_i=
  which(!index %in% index[test_i]) %>%
  sample(round(0.2*length(.)),F)

train_i=
  which(!index %in% index[c(test_i,val_i)])

tidy_set$outcome[index[c(train_i,val_i,test_i)]] %>%
  data.frame(
    outcome=.
    ,set=c(rep('train',length(train_i))
           ,rep('validation',length(val_i))
           ,rep('test',length(test_i)))
  ) %>%
  mutate(set=factor(set,c('train','validation','test'))) %>%
  table() %>%
  as.data.frame() %>%
  mutate(outcome=paste0('outcome_',outcome)) %>%
  spread(outcome,Freq) %>%
  knitr::kable(format='html',caption='Data partition') %>%
  kableExtra::kable_styling(full_width=T)
```

# Model training

We use this code to train the model. The sample generator for ontoarray will
take 32 samples for each batch. This step is repeated until all samples of
training set are used per epoch, up to 100 epochs, but can be stopped earlier.
For each epoch, validation performance is also measured with the same batch
size.

```{r Train the model, eval=FALSE, echo=TRUE}
history=
  ontonet %>%
  fit_generator(
    generator=
      ontoarray_generator(
        tidy_set
        ,index[train_i]
        ,batch_size=32
      )
    ,steps_per_epoch=ceiling(length(train_i)/32)
    ,validation_data=
      ontoarray_generator(
        tidy_set
        ,index[val_i]
        ,batch_size=32
      )
    ,validation_steps=ceiling(length(val_i)/32)
    ,epochs=100
    ,callbacks=c(cb_lr_reduction,cb_early_stopping)
    ,view_metrics=F
    ,verbose=1
  )
```
```{r include=FALSE}
history=readRDS('quick-start/history_R.rds')
load_model_weights_hdf5(ontonet,'quick-start/ontonet_R.h5')
```

Here below is the training result. We can estimate the iteration of which the
weights are optimum for prediction.

```{r figure-2, echo=FALSE, fig.cap='Plot training and validation losses'}
history$metrics %>%
  .[c('loss','val_loss')] %>%
  do.call(cbind,.) %>%
  as.data.frame() %>%
  mutate(iteration=seq(nrow(.))) %>%
  gather(metric,value,-iteration) %>%
  qplot(
    iteration,value,color=metric,data=.
    ,geom='smooth',method='loess',formula=y~x,se=F
  ) +
  theme_minimal()
```

# Model evaluation

The test set is used for model evaluation by bootstrapping. The sample generator
for ontoarray will take 32 samples for each batch. This step is repeated until
all samples of training set are used per bootstrap, until 30 times.

```{r Evaluate model on test set, eval=FALSE, echo=TRUE}
set.seed(33)
evaluation=
  pblapply(X=1:30,function(X){
    test_i=sample(test_i,length(test_i),T)
    ontonet %>%
      evaluate_generator(
        generator=
          ontoarray_generator(
            tidy_set
            ,index[test_i]
            ,batch_size=32
          )
        ,steps=ceiling(length(test_i)/32)
      )
  })
```
```{r include=FALSE}
evaluation=readRDS('quick-start/evaluation_R.rds')
```

The point and interval (95% CI) estimates of accuracy can be computed by
the bootstrapping.

```{r Compute point and interval estimates of accuracy, include=FALSE}
results=
  evaluation %>%
  lapply(X=seq(length(.)),Y=.,function(X,Y){
    as.data.frame(Y[[X]]) %>%
      gather(metric,value) %>%
      mutate(b=X)
  }) %>%
  do.call(rbind,.) %>%
  group_by(metric) %>%
  summarize(
    mean=mean(value)
    ,lb=mean(value)-qnorm(0.975)*sd(value)/sqrt(n())
    ,ub=mean(value)+qnorm(0.975)*sd(value)/sqrt(n())
  )
```

Therefore, the predictive performance of this model can be
generalized for future, unobserved samples.

```{r Show point and interval estimates of root accuracy, echo=FALSE}
results %>%
  filter(metric=='root_accuracy') %>%
  knitr::kable(
    format='html'
    ,caption='Accuracy estimates (95% CI) on test set'
  ) %>%
  kableExtra::kable_styling(full_width=T)
```

# Session info

```{r Session info}
sessionInfo()
```
